<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ArgNav.app.centrality API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ArgNav.app.centrality</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">from .load_map import CorpusLoader
from . import app
import json
import requests
from datetime import datetime
from pathlib import Path
import re

import networkx as nx

class Centrality:
    &#34;&#34;&#34;
    Class to perform operations over AIF graphs.

    The class pulls data from AIFdb through url creation, calls the translation of AIF json into a networkx directed graph.
    Functions also perform operations over the networkx graphs

    &#34;&#34;&#34;
    @staticmethod
    def get_nodeset_path(nodeset_id):
        &#34;&#34;&#34;
        Function to create a nodeset path based on the nodeset id in the examples folder
        &#34;&#34;&#34;
        directory_path = &#39;examples/&#39;
        node_path = directory_path + &#39;nodeset&#39; + nodeset_id + &#39;.json&#39;
        return node_path

    @staticmethod
    def get_svg_path(nodeset_id):
        &#34;&#34;&#34;
        Function to create an svg path based on the nodeset id in the examples folder
        &#34;&#34;&#34;
        #corpus_name = &#39;US2016tv&#39;
        directory_path = &#39;examples/&#39;
        node_path = directory_path + nodeset_id + &#39;.svg&#39;
        return node_path

    @staticmethod
    def create_svg_url(nodeset_id, isMap):
        &#34;&#34;&#34;
        Function to create an svg url based on the nodeset id or corpus shortname from aifdb
        Parameters

        nodeset_id: str
        isMap: Bool
            True if nodeset id
            False if corpus shortname
        &#34;&#34;&#34;
        if isMap:
            return &#39;http://www.aifdb.org/diagram/svg/&#39; + nodeset_id
        else:
            return &#39;http://corpora.aifdb.org/&#39; + nodeset_id + &#39;/svg/&#39;
        return node_path

    @staticmethod
    def create_json_url(nodeset_id, isMap):

        &#34;&#34;&#34;
        Function to create an AIFdb url based on the nodeset id or corpus shortname from aifdb


        Parameters
        ----------

        nodeset_id: str
        isMap: Bool
            True if nodeset id
            False if corpus shortname
        &#34;&#34;&#34;

        if isMap:
            return &#39;http://www.aifdb.org/json/&#39; + nodeset_id
        else:
            return &#39;http://corpora.aifdb.org/&#39; + nodeset_id + &#39;/json/&#39;
        return node_path

    @staticmethod
    def get_graph(node_path):
        &#34;&#34;&#34;
        Function to create a networkx graph from json data.
        Calls the corpus loader class, opens the file at a path, and returns the graph.

        Parameters
        ----------
        node_path: path to AIF json data to create networkx graph.
        &#34;&#34;&#34;
        corpus_loader = CorpusLoader()
        try:
            with app.open_resource(node_path) as json_data:
                graph = corpus_loader.parse_json(json.load(json_data))
        except(IOError):
            print(&#39;File was not found:&#39;)
            print(node_path)

        return graph

    @staticmethod
    def get_graph_url(node_path):
        &#34;&#34;&#34;
        Function to create a networkx graph from a url containing json data.
        Calls the corpus loader class, opens the file at the url, and returns the graph.

        Parameters
        ----------
        node_path: path to AIF json data to create networkx graph.
        &#34;&#34;&#34;
        corpus_loader = CorpusLoader()
        try:
            jsn_string = requests.get(node_path).text

            #Check for bracket to determine if string contains JSON data
            strng_ind = jsn_string.index(&#39;{&#39;)
            n_string = jsn_string[strng_ind:]
            dta = json.loads(n_string)
            graph = corpus_loader.parse_json(dta)
        except(IOError):
            print(&#39;File was not found:&#39;)
            print(node_path)

        return graph

    @staticmethod
    def remove_redundant_nodes(graph):
        &#34;&#34;&#34;
        Function to remove all IAT nodes leaving only AIF nodes - I-nodes and S-nodes

        Find the nodes,add them to a list and then remove from graph using networkx function.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        node_types=nx.get_node_attributes(graph,&#39;type&#39;)

        nodes_to_remove =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;TA&#39; or y[&#39;type&#39;]==&#39;L&#39; or y[&#39;type&#39;]==&#39;YA&#39;]

        graph.remove_nodes_from(nodes_to_remove)

        return graph

    @staticmethod
    def remove_iso_nodes(graph):
        &#34;&#34;&#34;
        Function to remove isolated nodes from the graph.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        graph.remove_nodes_from(list(nx.isolates(graph)))
        return graph

    @staticmethod
    def get_eigen_centrality(graph):
        &#34;&#34;&#34;
        Function to get centrality of I-nodes from a graph.

        Function calculates eigenvector centrality for all nodes and then selects I-nodes from the graph.
        Where Eigen vector centrality cannot converge an exception is thrown, at which point normalised degree centrality is used.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        try:
            cent = nx.eigenvector_centrality_numpy(graph)
        except:
            cent = nx.degree_centrality(graph)

        nx.set_node_attributes(graph, cent, &#39;central&#39;)
        i_nodes =  [(x,y[&#39;central&#39;],y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;I&#39;]
        return i_nodes

    @staticmethod
    def sort_by_centrality(i_nodes):
        &#34;&#34;&#34;
        Function to sort I-nodes by the centrality.

        Outputs a tuple of I-node ID and text.
        Parameters
        ----------
        i_nodes: I_nodes extracted from the aif graph
        &#34;&#34;&#34;
        sorted_by_second = sorted(i_nodes, key=lambda tup: tup[1])
        ordered_ids = [(i[0],i[2]) for i in sorted_by_second]

        return ordered_ids

    @staticmethod
    def get_schemes(graph):
        &#34;&#34;&#34;
        Function to get schemes from S-nodes.

        Function is implmented for all possible S-nodes, but currently only RAs have schemes.
        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        all_nodes =  [(x,y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;RA&#39; and y[&#39;text&#39;]!=&#39;Default Inference&#39; or y[&#39;type&#39;]==&#39;CA&#39; and y[&#39;text&#39;]!=&#39;Default Conflict&#39; or y[&#39;type&#39;]==&#39;MA&#39; and y[&#39;text&#39;]!=&#39;Default Rephrase&#39;]
        return all_nodes

    @staticmethod
    def get_ra_i_schemes_nodes(graph, scheme_ras):
        &#34;&#34;&#34;
        Function to get the I-node connected to a scheme s-node.

        Function is implmented for all possible S-nodes, but currently only RAs have schemes.
        Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
        Therefore, the first element from the returned list is taken.
        Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
        Parameters
        ----------
        graph: aif_graph for corpus
        scheme_ras: all s-nodes that contain some form of scheme - i.e. not a default
        &#34;&#34;&#34;
        ra_tups = []
        for ra in scheme_ras:
            node_succ = list(graph.successors(ra[0]))
            i_1 = node_succ[0]
            i_1_text = graph.nodes[i_1][&#39;text&#39;]

            ra_tup = (ra[0], ra[1],i_1, i_1_text)
            ra_tups.append(ra_tup)
        return ra_tups

    @staticmethod
    def get_all_schemes_nodes(graph, scheme_ras):
        &#34;&#34;&#34;
        Function to get the I-nodes connected to a scheme s-node - both incoming and outgoing.

        Function is implmented for all possible S-nodes, but currently only RAs have schemes.
        Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
        Therefore, the first element from the returned list is taken.
        Function thentakes an S-node and finds all predecessors of the node. An S-node may have several incoming I-nodes. If an IAT graph it will also have connections to a YA node which can be ignored.
        Therefore, the list is iterated.
        Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
        Parameters
        ----------
        graph: aif_graph for corpus
        scheme_ras: all s-nodes that contain some form of scheme - i.e. not a default
        &#34;&#34;&#34;
        ra_tups = []
        for ra in scheme_ras:
            node_succ = list(graph.successors(ra[0]))
            s_tup = (ra[0], ra[1],ra[0], ra[1])
            ra_tups.append(s_tup)
            i_1 = node_succ[0]
            i_1_text = graph.nodes[i_1][&#39;text&#39;]

            ra_tup = (ra[0], ra[1],i_1, i_1_text)
            ra_tups.append(ra_tup)

            node_pred = list(graph.predecessors(ra[0]))
            for ns in node_pred:
                i_2_text = graph.nodes[ns][&#39;text&#39;]
                i_2_type = graph.nodes[ns][&#39;type&#39;]

                if i_2_type != &#39;YA&#39;:
                    ra_tup_2 = (ra[0], ra[1],ns, i_2_text)
                    ra_tups.append(ra_tup_2)
        return ra_tups

    @staticmethod
    def list_nodes(graph):
        &#34;&#34;&#34;
        Function to get all nodes from a graph in a list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        return list(graph)

    @staticmethod
    def get_s_node_list(graph):
        &#34;&#34;&#34;
        Function to get all S-nodes from a graph in a list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        s_nodes =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;MA&#39; or y[&#39;type&#39;]==&#39;RA&#39; or y[&#39;type&#39;]==&#39;CA&#39; or y[&#39;type&#39;]==&#39;PA&#39;]
        return s_nodes


    @staticmethod
    def get_l_node_list(graph):
        &#34;&#34;&#34;
        Function to get all l-nodes from a graph in a list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        l_nodes =  [(x,y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;L&#39;]
        return l_nodes

    @staticmethod
    def get_divergent_nodes(graph):
        &#34;&#34;&#34;
        Function to get all I-nodes that have multiple outgoing edges.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        list_of_nodes = []

        for v in list(graph.nodes):
            node_pres = []
            node_pres = list(graph.successors(v))
            if len(node_pres) &gt; 1:
                list_of_nodes.append(v)
        return list_of_nodes

    @staticmethod
    def get_loc_prop_pair(graph):
        &#34;&#34;&#34;
        Function to get all L-nodes that are connected to an I-node through a YA-node.

        First find all predeccessors of an I-node, iterate these nodes to ensure they are YAs. Agreeing YAs have a different format so ignore these.

        From the YAs find all predeccessors, get the corresponding L-nodes for the I-node.

        Return a locution - I-node ID tuple list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        i_node_ids =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;I&#39;]
        locution_prop_pair = []
        for node_id in i_node_ids:
            preds = list(graph.predecessors(node_id))
            for pred in preds:
                node_type=graph.nodes[pred][&#39;type&#39;]
                node_text = graph.nodes[pred][&#39;text&#39;]

                if node_type == &#39;YA&#39; and node_text != &#39;Agreeing&#39;:
                    ya_preds = list(graph.predecessors(pred))
                    for ya_pred in ya_preds:
                        pred_node_type=graph.nodes[ya_pred][&#39;type&#39;]
                        pred_node_text=graph.nodes[ya_pred][&#39;text&#39;]

                        if pred_node_type == &#39;L&#39;:
                            locution_prop_pair.append((ya_pred, node_id))
        return locution_prop_pair

    @staticmethod
    def get_child_edges(graph):
        &#34;&#34;&#34;
        Function to get all edges connected to a node as a child of the node.

        First find all the ancestors of a node.

        Find all edges connected to node in reverse.

        Return list of nodes and tuples, with conclusion node as first element and a list as second element.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        list_of_nodes = []
        list_of_edges = []

        for v in list(graph.nodes):
            node_pres = []
            node_pres = list(nx.ancestors(graph, v))
            list_of_nodes.append((v, node_pres))
            edges = []
            edges = list(nx.edge_dfs(graph,v, orientation=&#39;reverse&#39;))
            res_list = []
            res_list = [(x[0], x[1]) for x in edges]
            list_of_edges.append((v, res_list))

        return list_of_nodes, list_of_edges

    @staticmethod
    def get_all_edges(graph):
        &#34;&#34;&#34;
        Function to get all edges connected to a node in both directions from the node.

        First find all the ancestors of a node.

        Find all edges connected to node using in and out edge functions.

        Return list of nodes and tuples, with conclusion node as first element and a list as second element.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;

        list_of_nodes = []
        list_of_edges = []

        for v in list(graph.nodes):
            node_pres = []
            node_pres = list(nx.ancestors(graph, v))
            list_of_nodes.append((v, node_pres))
            edges = []
            edges = list(graph.in_edges(v))
            res_list = []
            res_list = [(x[0], x[1]) for x in edges]
            list_of_edges.append((v, res_list))
            edges_1 = []
            edges_1 = list(graph.out_edges(v))
            res_list1= []
            res_list1 = [(x[0], x[1]) for x in edges_1]
            list_of_edges.append((v, res_list1))

        return list_of_nodes, list_of_edges</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ArgNav.app.centrality.Centrality"><code class="flex name class">
<span>class <span class="ident">Centrality</span></span>
</code></dt>
<dd>
<div class="desc"><p>Class to perform operations over AIF graphs.</p>
<p>The class pulls data from AIFdb through url creation, calls the translation of AIF json into a networkx directed graph.
Functions also perform operations over the networkx graphs</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Centrality:
    &#34;&#34;&#34;
    Class to perform operations over AIF graphs.

    The class pulls data from AIFdb through url creation, calls the translation of AIF json into a networkx directed graph.
    Functions also perform operations over the networkx graphs

    &#34;&#34;&#34;
    @staticmethod
    def get_nodeset_path(nodeset_id):
        &#34;&#34;&#34;
        Function to create a nodeset path based on the nodeset id in the examples folder
        &#34;&#34;&#34;
        directory_path = &#39;examples/&#39;
        node_path = directory_path + &#39;nodeset&#39; + nodeset_id + &#39;.json&#39;
        return node_path

    @staticmethod
    def get_svg_path(nodeset_id):
        &#34;&#34;&#34;
        Function to create an svg path based on the nodeset id in the examples folder
        &#34;&#34;&#34;
        #corpus_name = &#39;US2016tv&#39;
        directory_path = &#39;examples/&#39;
        node_path = directory_path + nodeset_id + &#39;.svg&#39;
        return node_path

    @staticmethod
    def create_svg_url(nodeset_id, isMap):
        &#34;&#34;&#34;
        Function to create an svg url based on the nodeset id or corpus shortname from aifdb
        Parameters

        nodeset_id: str
        isMap: Bool
            True if nodeset id
            False if corpus shortname
        &#34;&#34;&#34;
        if isMap:
            return &#39;http://www.aifdb.org/diagram/svg/&#39; + nodeset_id
        else:
            return &#39;http://corpora.aifdb.org/&#39; + nodeset_id + &#39;/svg/&#39;
        return node_path

    @staticmethod
    def create_json_url(nodeset_id, isMap):

        &#34;&#34;&#34;
        Function to create an AIFdb url based on the nodeset id or corpus shortname from aifdb


        Parameters
        ----------

        nodeset_id: str
        isMap: Bool
            True if nodeset id
            False if corpus shortname
        &#34;&#34;&#34;

        if isMap:
            return &#39;http://www.aifdb.org/json/&#39; + nodeset_id
        else:
            return &#39;http://corpora.aifdb.org/&#39; + nodeset_id + &#39;/json/&#39;
        return node_path

    @staticmethod
    def get_graph(node_path):
        &#34;&#34;&#34;
        Function to create a networkx graph from json data.
        Calls the corpus loader class, opens the file at a path, and returns the graph.

        Parameters
        ----------
        node_path: path to AIF json data to create networkx graph.
        &#34;&#34;&#34;
        corpus_loader = CorpusLoader()
        try:
            with app.open_resource(node_path) as json_data:
                graph = corpus_loader.parse_json(json.load(json_data))
        except(IOError):
            print(&#39;File was not found:&#39;)
            print(node_path)

        return graph

    @staticmethod
    def get_graph_url(node_path):
        &#34;&#34;&#34;
        Function to create a networkx graph from a url containing json data.
        Calls the corpus loader class, opens the file at the url, and returns the graph.

        Parameters
        ----------
        node_path: path to AIF json data to create networkx graph.
        &#34;&#34;&#34;
        corpus_loader = CorpusLoader()
        try:
            jsn_string = requests.get(node_path).text

            #Check for bracket to determine if string contains JSON data
            strng_ind = jsn_string.index(&#39;{&#39;)
            n_string = jsn_string[strng_ind:]
            dta = json.loads(n_string)
            graph = corpus_loader.parse_json(dta)
        except(IOError):
            print(&#39;File was not found:&#39;)
            print(node_path)

        return graph

    @staticmethod
    def remove_redundant_nodes(graph):
        &#34;&#34;&#34;
        Function to remove all IAT nodes leaving only AIF nodes - I-nodes and S-nodes

        Find the nodes,add them to a list and then remove from graph using networkx function.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        node_types=nx.get_node_attributes(graph,&#39;type&#39;)

        nodes_to_remove =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;TA&#39; or y[&#39;type&#39;]==&#39;L&#39; or y[&#39;type&#39;]==&#39;YA&#39;]

        graph.remove_nodes_from(nodes_to_remove)

        return graph

    @staticmethod
    def remove_iso_nodes(graph):
        &#34;&#34;&#34;
        Function to remove isolated nodes from the graph.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        graph.remove_nodes_from(list(nx.isolates(graph)))
        return graph

    @staticmethod
    def get_eigen_centrality(graph):
        &#34;&#34;&#34;
        Function to get centrality of I-nodes from a graph.

        Function calculates eigenvector centrality for all nodes and then selects I-nodes from the graph.
        Where Eigen vector centrality cannot converge an exception is thrown, at which point normalised degree centrality is used.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        try:
            cent = nx.eigenvector_centrality_numpy(graph)
        except:
            cent = nx.degree_centrality(graph)

        nx.set_node_attributes(graph, cent, &#39;central&#39;)
        i_nodes =  [(x,y[&#39;central&#39;],y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;I&#39;]
        return i_nodes

    @staticmethod
    def sort_by_centrality(i_nodes):
        &#34;&#34;&#34;
        Function to sort I-nodes by the centrality.

        Outputs a tuple of I-node ID and text.
        Parameters
        ----------
        i_nodes: I_nodes extracted from the aif graph
        &#34;&#34;&#34;
        sorted_by_second = sorted(i_nodes, key=lambda tup: tup[1])
        ordered_ids = [(i[0],i[2]) for i in sorted_by_second]

        return ordered_ids

    @staticmethod
    def get_schemes(graph):
        &#34;&#34;&#34;
        Function to get schemes from S-nodes.

        Function is implmented for all possible S-nodes, but currently only RAs have schemes.
        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        all_nodes =  [(x,y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;RA&#39; and y[&#39;text&#39;]!=&#39;Default Inference&#39; or y[&#39;type&#39;]==&#39;CA&#39; and y[&#39;text&#39;]!=&#39;Default Conflict&#39; or y[&#39;type&#39;]==&#39;MA&#39; and y[&#39;text&#39;]!=&#39;Default Rephrase&#39;]
        return all_nodes

    @staticmethod
    def get_ra_i_schemes_nodes(graph, scheme_ras):
        &#34;&#34;&#34;
        Function to get the I-node connected to a scheme s-node.

        Function is implmented for all possible S-nodes, but currently only RAs have schemes.
        Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
        Therefore, the first element from the returned list is taken.
        Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
        Parameters
        ----------
        graph: aif_graph for corpus
        scheme_ras: all s-nodes that contain some form of scheme - i.e. not a default
        &#34;&#34;&#34;
        ra_tups = []
        for ra in scheme_ras:
            node_succ = list(graph.successors(ra[0]))
            i_1 = node_succ[0]
            i_1_text = graph.nodes[i_1][&#39;text&#39;]

            ra_tup = (ra[0], ra[1],i_1, i_1_text)
            ra_tups.append(ra_tup)
        return ra_tups

    @staticmethod
    def get_all_schemes_nodes(graph, scheme_ras):
        &#34;&#34;&#34;
        Function to get the I-nodes connected to a scheme s-node - both incoming and outgoing.

        Function is implmented for all possible S-nodes, but currently only RAs have schemes.
        Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
        Therefore, the first element from the returned list is taken.
        Function thentakes an S-node and finds all predecessors of the node. An S-node may have several incoming I-nodes. If an IAT graph it will also have connections to a YA node which can be ignored.
        Therefore, the list is iterated.
        Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
        Parameters
        ----------
        graph: aif_graph for corpus
        scheme_ras: all s-nodes that contain some form of scheme - i.e. not a default
        &#34;&#34;&#34;
        ra_tups = []
        for ra in scheme_ras:
            node_succ = list(graph.successors(ra[0]))
            s_tup = (ra[0], ra[1],ra[0], ra[1])
            ra_tups.append(s_tup)
            i_1 = node_succ[0]
            i_1_text = graph.nodes[i_1][&#39;text&#39;]

            ra_tup = (ra[0], ra[1],i_1, i_1_text)
            ra_tups.append(ra_tup)

            node_pred = list(graph.predecessors(ra[0]))
            for ns in node_pred:
                i_2_text = graph.nodes[ns][&#39;text&#39;]
                i_2_type = graph.nodes[ns][&#39;type&#39;]

                if i_2_type != &#39;YA&#39;:
                    ra_tup_2 = (ra[0], ra[1],ns, i_2_text)
                    ra_tups.append(ra_tup_2)
        return ra_tups

    @staticmethod
    def list_nodes(graph):
        &#34;&#34;&#34;
        Function to get all nodes from a graph in a list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        return list(graph)

    @staticmethod
    def get_s_node_list(graph):
        &#34;&#34;&#34;
        Function to get all S-nodes from a graph in a list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        s_nodes =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;MA&#39; or y[&#39;type&#39;]==&#39;RA&#39; or y[&#39;type&#39;]==&#39;CA&#39; or y[&#39;type&#39;]==&#39;PA&#39;]
        return s_nodes


    @staticmethod
    def get_l_node_list(graph):
        &#34;&#34;&#34;
        Function to get all l-nodes from a graph in a list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        l_nodes =  [(x,y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;L&#39;]
        return l_nodes

    @staticmethod
    def get_divergent_nodes(graph):
        &#34;&#34;&#34;
        Function to get all I-nodes that have multiple outgoing edges.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        list_of_nodes = []

        for v in list(graph.nodes):
            node_pres = []
            node_pres = list(graph.successors(v))
            if len(node_pres) &gt; 1:
                list_of_nodes.append(v)
        return list_of_nodes

    @staticmethod
    def get_loc_prop_pair(graph):
        &#34;&#34;&#34;
        Function to get all L-nodes that are connected to an I-node through a YA-node.

        First find all predeccessors of an I-node, iterate these nodes to ensure they are YAs. Agreeing YAs have a different format so ignore these.

        From the YAs find all predeccessors, get the corresponding L-nodes for the I-node.

        Return a locution - I-node ID tuple list.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        i_node_ids =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;I&#39;]
        locution_prop_pair = []
        for node_id in i_node_ids:
            preds = list(graph.predecessors(node_id))
            for pred in preds:
                node_type=graph.nodes[pred][&#39;type&#39;]
                node_text = graph.nodes[pred][&#39;text&#39;]

                if node_type == &#39;YA&#39; and node_text != &#39;Agreeing&#39;:
                    ya_preds = list(graph.predecessors(pred))
                    for ya_pred in ya_preds:
                        pred_node_type=graph.nodes[ya_pred][&#39;type&#39;]
                        pred_node_text=graph.nodes[ya_pred][&#39;text&#39;]

                        if pred_node_type == &#39;L&#39;:
                            locution_prop_pair.append((ya_pred, node_id))
        return locution_prop_pair

    @staticmethod
    def get_child_edges(graph):
        &#34;&#34;&#34;
        Function to get all edges connected to a node as a child of the node.

        First find all the ancestors of a node.

        Find all edges connected to node in reverse.

        Return list of nodes and tuples, with conclusion node as first element and a list as second element.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;
        list_of_nodes = []
        list_of_edges = []

        for v in list(graph.nodes):
            node_pres = []
            node_pres = list(nx.ancestors(graph, v))
            list_of_nodes.append((v, node_pres))
            edges = []
            edges = list(nx.edge_dfs(graph,v, orientation=&#39;reverse&#39;))
            res_list = []
            res_list = [(x[0], x[1]) for x in edges]
            list_of_edges.append((v, res_list))

        return list_of_nodes, list_of_edges

    @staticmethod
    def get_all_edges(graph):
        &#34;&#34;&#34;
        Function to get all edges connected to a node in both directions from the node.

        First find all the ancestors of a node.

        Find all edges connected to node using in and out edge functions.

        Return list of nodes and tuples, with conclusion node as first element and a list as second element.

        Parameters
        ----------
        graph: aif_graph for corpus
        &#34;&#34;&#34;

        list_of_nodes = []
        list_of_edges = []

        for v in list(graph.nodes):
            node_pres = []
            node_pres = list(nx.ancestors(graph, v))
            list_of_nodes.append((v, node_pres))
            edges = []
            edges = list(graph.in_edges(v))
            res_list = []
            res_list = [(x[0], x[1]) for x in edges]
            list_of_edges.append((v, res_list))
            edges_1 = []
            edges_1 = list(graph.out_edges(v))
            res_list1= []
            res_list1 = [(x[0], x[1]) for x in edges_1]
            list_of_edges.append((v, res_list1))

        return list_of_nodes, list_of_edges</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="ArgNav.app.centrality.Centrality.create_json_url"><code class="name flex">
<span>def <span class="ident">create_json_url</span></span>(<span>nodeset_id, isMap)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create an AIFdb url based on the nodeset id or corpus shortname from aifdb</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>nodeset_id</code></strong> :&ensp;<code>str</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>isMap</code></strong> :&ensp;<code>Bool</code></dt>
<dd>True if nodeset id
False if corpus shortname</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_json_url(nodeset_id, isMap):

    &#34;&#34;&#34;
    Function to create an AIFdb url based on the nodeset id or corpus shortname from aifdb


    Parameters
    ----------

    nodeset_id: str
    isMap: Bool
        True if nodeset id
        False if corpus shortname
    &#34;&#34;&#34;

    if isMap:
        return &#39;http://www.aifdb.org/json/&#39; + nodeset_id
    else:
        return &#39;http://corpora.aifdb.org/&#39; + nodeset_id + &#39;/json/&#39;
    return node_path</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.create_svg_url"><code class="name flex">
<span>def <span class="ident">create_svg_url</span></span>(<span>nodeset_id, isMap)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create an svg url based on the nodeset id or corpus shortname from aifdb
Parameters</p>
<p>nodeset_id: str
isMap: Bool
True if nodeset id
False if corpus shortname</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def create_svg_url(nodeset_id, isMap):
    &#34;&#34;&#34;
    Function to create an svg url based on the nodeset id or corpus shortname from aifdb
    Parameters

    nodeset_id: str
    isMap: Bool
        True if nodeset id
        False if corpus shortname
    &#34;&#34;&#34;
    if isMap:
        return &#39;http://www.aifdb.org/diagram/svg/&#39; + nodeset_id
    else:
        return &#39;http://corpora.aifdb.org/&#39; + nodeset_id + &#39;/svg/&#39;
    return node_path</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_all_edges"><code class="name flex">
<span>def <span class="ident">get_all_edges</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all edges connected to a node in both directions from the node.</p>
<p>First find all the ancestors of a node.</p>
<p>Find all edges connected to node using in and out edge functions.</p>
<p>Return list of nodes and tuples, with conclusion node as first element and a list as second element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_all_edges(graph):
    &#34;&#34;&#34;
    Function to get all edges connected to a node in both directions from the node.

    First find all the ancestors of a node.

    Find all edges connected to node using in and out edge functions.

    Return list of nodes and tuples, with conclusion node as first element and a list as second element.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;

    list_of_nodes = []
    list_of_edges = []

    for v in list(graph.nodes):
        node_pres = []
        node_pres = list(nx.ancestors(graph, v))
        list_of_nodes.append((v, node_pres))
        edges = []
        edges = list(graph.in_edges(v))
        res_list = []
        res_list = [(x[0], x[1]) for x in edges]
        list_of_edges.append((v, res_list))
        edges_1 = []
        edges_1 = list(graph.out_edges(v))
        res_list1= []
        res_list1 = [(x[0], x[1]) for x in edges_1]
        list_of_edges.append((v, res_list1))

    return list_of_nodes, list_of_edges</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_all_schemes_nodes"><code class="name flex">
<span>def <span class="ident">get_all_schemes_nodes</span></span>(<span>graph, scheme_ras)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get the I-nodes connected to a scheme s-node - both incoming and outgoing.</p>
<p>Function is implmented for all possible S-nodes, but currently only RAs have schemes.
Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
Therefore, the first element from the returned list is taken.
Function thentakes an S-node and finds all predecessors of the node. An S-node may have several incoming I-nodes. If an IAT graph it will also have connections to a YA node which can be ignored.
Therefore, the list is iterated.
Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
Parameters</p>
<hr>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>scheme_ras</code></strong> :&ensp;<code>all s-nodes that contain some form</code> of <code>scheme - i.e. not a default</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_all_schemes_nodes(graph, scheme_ras):
    &#34;&#34;&#34;
    Function to get the I-nodes connected to a scheme s-node - both incoming and outgoing.

    Function is implmented for all possible S-nodes, but currently only RAs have schemes.
    Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
    Therefore, the first element from the returned list is taken.
    Function thentakes an S-node and finds all predecessors of the node. An S-node may have several incoming I-nodes. If an IAT graph it will also have connections to a YA node which can be ignored.
    Therefore, the list is iterated.
    Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
    Parameters
    ----------
    graph: aif_graph for corpus
    scheme_ras: all s-nodes that contain some form of scheme - i.e. not a default
    &#34;&#34;&#34;
    ra_tups = []
    for ra in scheme_ras:
        node_succ = list(graph.successors(ra[0]))
        s_tup = (ra[0], ra[1],ra[0], ra[1])
        ra_tups.append(s_tup)
        i_1 = node_succ[0]
        i_1_text = graph.nodes[i_1][&#39;text&#39;]

        ra_tup = (ra[0], ra[1],i_1, i_1_text)
        ra_tups.append(ra_tup)

        node_pred = list(graph.predecessors(ra[0]))
        for ns in node_pred:
            i_2_text = graph.nodes[ns][&#39;text&#39;]
            i_2_type = graph.nodes[ns][&#39;type&#39;]

            if i_2_type != &#39;YA&#39;:
                ra_tup_2 = (ra[0], ra[1],ns, i_2_text)
                ra_tups.append(ra_tup_2)
    return ra_tups</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_child_edges"><code class="name flex">
<span>def <span class="ident">get_child_edges</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all edges connected to a node as a child of the node.</p>
<p>First find all the ancestors of a node.</p>
<p>Find all edges connected to node in reverse.</p>
<p>Return list of nodes and tuples, with conclusion node as first element and a list as second element.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_child_edges(graph):
    &#34;&#34;&#34;
    Function to get all edges connected to a node as a child of the node.

    First find all the ancestors of a node.

    Find all edges connected to node in reverse.

    Return list of nodes and tuples, with conclusion node as first element and a list as second element.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    list_of_nodes = []
    list_of_edges = []

    for v in list(graph.nodes):
        node_pres = []
        node_pres = list(nx.ancestors(graph, v))
        list_of_nodes.append((v, node_pres))
        edges = []
        edges = list(nx.edge_dfs(graph,v, orientation=&#39;reverse&#39;))
        res_list = []
        res_list = [(x[0], x[1]) for x in edges]
        list_of_edges.append((v, res_list))

    return list_of_nodes, list_of_edges</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_divergent_nodes"><code class="name flex">
<span>def <span class="ident">get_divergent_nodes</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all I-nodes that have multiple outgoing edges.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_divergent_nodes(graph):
    &#34;&#34;&#34;
    Function to get all I-nodes that have multiple outgoing edges.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    list_of_nodes = []

    for v in list(graph.nodes):
        node_pres = []
        node_pres = list(graph.successors(v))
        if len(node_pres) &gt; 1:
            list_of_nodes.append(v)
    return list_of_nodes</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_eigen_centrality"><code class="name flex">
<span>def <span class="ident">get_eigen_centrality</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get centrality of I-nodes from a graph.</p>
<p>Function calculates eigenvector centrality for all nodes and then selects I-nodes from the graph.
Where Eigen vector centrality cannot converge an exception is thrown, at which point normalised degree centrality is used.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_eigen_centrality(graph):
    &#34;&#34;&#34;
    Function to get centrality of I-nodes from a graph.

    Function calculates eigenvector centrality for all nodes and then selects I-nodes from the graph.
    Where Eigen vector centrality cannot converge an exception is thrown, at which point normalised degree centrality is used.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    try:
        cent = nx.eigenvector_centrality_numpy(graph)
    except:
        cent = nx.degree_centrality(graph)

    nx.set_node_attributes(graph, cent, &#39;central&#39;)
    i_nodes =  [(x,y[&#39;central&#39;],y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;I&#39;]
    return i_nodes</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_graph"><code class="name flex">
<span>def <span class="ident">get_graph</span></span>(<span>node_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create a networkx graph from json data.
Calls the corpus loader class, opens the file at a path, and returns the graph.</p>
<h2 id="parameters">Parameters</h2>
<p>node_path: path to AIF json data to create networkx graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_graph(node_path):
    &#34;&#34;&#34;
    Function to create a networkx graph from json data.
    Calls the corpus loader class, opens the file at a path, and returns the graph.

    Parameters
    ----------
    node_path: path to AIF json data to create networkx graph.
    &#34;&#34;&#34;
    corpus_loader = CorpusLoader()
    try:
        with app.open_resource(node_path) as json_data:
            graph = corpus_loader.parse_json(json.load(json_data))
    except(IOError):
        print(&#39;File was not found:&#39;)
        print(node_path)

    return graph</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_graph_url"><code class="name flex">
<span>def <span class="ident">get_graph_url</span></span>(<span>node_path)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create a networkx graph from a url containing json data.
Calls the corpus loader class, opens the file at the url, and returns the graph.</p>
<h2 id="parameters">Parameters</h2>
<p>node_path: path to AIF json data to create networkx graph.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_graph_url(node_path):
    &#34;&#34;&#34;
    Function to create a networkx graph from a url containing json data.
    Calls the corpus loader class, opens the file at the url, and returns the graph.

    Parameters
    ----------
    node_path: path to AIF json data to create networkx graph.
    &#34;&#34;&#34;
    corpus_loader = CorpusLoader()
    try:
        jsn_string = requests.get(node_path).text

        #Check for bracket to determine if string contains JSON data
        strng_ind = jsn_string.index(&#39;{&#39;)
        n_string = jsn_string[strng_ind:]
        dta = json.loads(n_string)
        graph = corpus_loader.parse_json(dta)
    except(IOError):
        print(&#39;File was not found:&#39;)
        print(node_path)

    return graph</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_l_node_list"><code class="name flex">
<span>def <span class="ident">get_l_node_list</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all l-nodes from a graph in a list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_l_node_list(graph):
    &#34;&#34;&#34;
    Function to get all l-nodes from a graph in a list.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    l_nodes =  [(x,y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;L&#39;]
    return l_nodes</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_loc_prop_pair"><code class="name flex">
<span>def <span class="ident">get_loc_prop_pair</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all L-nodes that are connected to an I-node through a YA-node.</p>
<p>First find all predeccessors of an I-node, iterate these nodes to ensure they are YAs. Agreeing YAs have a different format so ignore these.</p>
<p>From the YAs find all predeccessors, get the corresponding L-nodes for the I-node.</p>
<p>Return a locution - I-node ID tuple list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_loc_prop_pair(graph):
    &#34;&#34;&#34;
    Function to get all L-nodes that are connected to an I-node through a YA-node.

    First find all predeccessors of an I-node, iterate these nodes to ensure they are YAs. Agreeing YAs have a different format so ignore these.

    From the YAs find all predeccessors, get the corresponding L-nodes for the I-node.

    Return a locution - I-node ID tuple list.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    i_node_ids =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;I&#39;]
    locution_prop_pair = []
    for node_id in i_node_ids:
        preds = list(graph.predecessors(node_id))
        for pred in preds:
            node_type=graph.nodes[pred][&#39;type&#39;]
            node_text = graph.nodes[pred][&#39;text&#39;]

            if node_type == &#39;YA&#39; and node_text != &#39;Agreeing&#39;:
                ya_preds = list(graph.predecessors(pred))
                for ya_pred in ya_preds:
                    pred_node_type=graph.nodes[ya_pred][&#39;type&#39;]
                    pred_node_text=graph.nodes[ya_pred][&#39;text&#39;]

                    if pred_node_type == &#39;L&#39;:
                        locution_prop_pair.append((ya_pred, node_id))
    return locution_prop_pair</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_nodeset_path"><code class="name flex">
<span>def <span class="ident">get_nodeset_path</span></span>(<span>nodeset_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create a nodeset path based on the nodeset id in the examples folder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_nodeset_path(nodeset_id):
    &#34;&#34;&#34;
    Function to create a nodeset path based on the nodeset id in the examples folder
    &#34;&#34;&#34;
    directory_path = &#39;examples/&#39;
    node_path = directory_path + &#39;nodeset&#39; + nodeset_id + &#39;.json&#39;
    return node_path</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_ra_i_schemes_nodes"><code class="name flex">
<span>def <span class="ident">get_ra_i_schemes_nodes</span></span>(<span>graph, scheme_ras)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get the I-node connected to a scheme s-node.</p>
<p>Function is implmented for all possible S-nodes, but currently only RAs have schemes.
Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
Therefore, the first element from the returned list is taken.
Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
Parameters</p>
<hr>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
<dt><strong><code>scheme_ras</code></strong> :&ensp;<code>all s-nodes that contain some form</code> of <code>scheme - i.e. not a default</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_ra_i_schemes_nodes(graph, scheme_ras):
    &#34;&#34;&#34;
    Function to get the I-node connected to a scheme s-node.

    Function is implmented for all possible S-nodes, but currently only RAs have schemes.
    Function takes an S-node and finds all successors of the node. An S-node should only have a single outgoing edge to an I-node.
    Therefore, the first element from the returned list is taken.
    Outputs a tuple containing the S-node ID, s-node text I_node id and I-node text.
    Parameters
    ----------
    graph: aif_graph for corpus
    scheme_ras: all s-nodes that contain some form of scheme - i.e. not a default
    &#34;&#34;&#34;
    ra_tups = []
    for ra in scheme_ras:
        node_succ = list(graph.successors(ra[0]))
        i_1 = node_succ[0]
        i_1_text = graph.nodes[i_1][&#39;text&#39;]

        ra_tup = (ra[0], ra[1],i_1, i_1_text)
        ra_tups.append(ra_tup)
    return ra_tups</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_s_node_list"><code class="name flex">
<span>def <span class="ident">get_s_node_list</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all S-nodes from a graph in a list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_s_node_list(graph):
    &#34;&#34;&#34;
    Function to get all S-nodes from a graph in a list.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    s_nodes =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;MA&#39; or y[&#39;type&#39;]==&#39;RA&#39; or y[&#39;type&#39;]==&#39;CA&#39; or y[&#39;type&#39;]==&#39;PA&#39;]
    return s_nodes</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_schemes"><code class="name flex">
<span>def <span class="ident">get_schemes</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get schemes from S-nodes.</p>
<p>Function is implmented for all possible S-nodes, but currently only RAs have schemes.
Parameters</p>
<hr>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_schemes(graph):
    &#34;&#34;&#34;
    Function to get schemes from S-nodes.

    Function is implmented for all possible S-nodes, but currently only RAs have schemes.
    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    all_nodes =  [(x,y[&#39;text&#39;]) for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;RA&#39; and y[&#39;text&#39;]!=&#39;Default Inference&#39; or y[&#39;type&#39;]==&#39;CA&#39; and y[&#39;text&#39;]!=&#39;Default Conflict&#39; or y[&#39;type&#39;]==&#39;MA&#39; and y[&#39;text&#39;]!=&#39;Default Rephrase&#39;]
    return all_nodes</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.get_svg_path"><code class="name flex">
<span>def <span class="ident">get_svg_path</span></span>(<span>nodeset_id)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to create an svg path based on the nodeset id in the examples folder</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def get_svg_path(nodeset_id):
    &#34;&#34;&#34;
    Function to create an svg path based on the nodeset id in the examples folder
    &#34;&#34;&#34;
    #corpus_name = &#39;US2016tv&#39;
    directory_path = &#39;examples/&#39;
    node_path = directory_path + nodeset_id + &#39;.svg&#39;
    return node_path</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.list_nodes"><code class="name flex">
<span>def <span class="ident">list_nodes</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to get all nodes from a graph in a list.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def list_nodes(graph):
    &#34;&#34;&#34;
    Function to get all nodes from a graph in a list.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    return list(graph)</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.remove_iso_nodes"><code class="name flex">
<span>def <span class="ident">remove_iso_nodes</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove isolated nodes from the graph.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_iso_nodes(graph):
    &#34;&#34;&#34;
    Function to remove isolated nodes from the graph.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    graph.remove_nodes_from(list(nx.isolates(graph)))
    return graph</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.remove_redundant_nodes"><code class="name flex">
<span>def <span class="ident">remove_redundant_nodes</span></span>(<span>graph)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to remove all IAT nodes leaving only AIF nodes - I-nodes and S-nodes</p>
<p>Find the nodes,add them to a list and then remove from graph using networkx function.</p>
<h2 id="parameters">Parameters</h2>
<dl>
<dt><strong><code>graph</code></strong> :&ensp;<code>aif_graph for corpus</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def remove_redundant_nodes(graph):
    &#34;&#34;&#34;
    Function to remove all IAT nodes leaving only AIF nodes - I-nodes and S-nodes

    Find the nodes,add them to a list and then remove from graph using networkx function.

    Parameters
    ----------
    graph: aif_graph for corpus
    &#34;&#34;&#34;
    node_types=nx.get_node_attributes(graph,&#39;type&#39;)

    nodes_to_remove =  [x for x,y in graph.nodes(data=True) if y[&#39;type&#39;]==&#39;TA&#39; or y[&#39;type&#39;]==&#39;L&#39; or y[&#39;type&#39;]==&#39;YA&#39;]

    graph.remove_nodes_from(nodes_to_remove)

    return graph</code></pre>
</details>
</dd>
<dt id="ArgNav.app.centrality.Centrality.sort_by_centrality"><code class="name flex">
<span>def <span class="ident">sort_by_centrality</span></span>(<span>i_nodes)</span>
</code></dt>
<dd>
<div class="desc"><p>Function to sort I-nodes by the centrality.</p>
<p>Outputs a tuple of I-node ID and text.
Parameters</p>
<hr>
<dl>
<dt><strong><code>i_nodes</code></strong> :&ensp;<code>I_nodes extracted from the aif graph</code></dt>
<dd>&nbsp;</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@staticmethod
def sort_by_centrality(i_nodes):
    &#34;&#34;&#34;
    Function to sort I-nodes by the centrality.

    Outputs a tuple of I-node ID and text.
    Parameters
    ----------
    i_nodes: I_nodes extracted from the aif graph
    &#34;&#34;&#34;
    sorted_by_second = sorted(i_nodes, key=lambda tup: tup[1])
    ordered_ids = [(i[0],i[2]) for i in sorted_by_second]

    return ordered_ids</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ArgNav.app" href="index.html">ArgNav.app</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ArgNav.app.centrality.Centrality" href="#ArgNav.app.centrality.Centrality">Centrality</a></code></h4>
<ul class="">
<li><code><a title="ArgNav.app.centrality.Centrality.create_json_url" href="#ArgNav.app.centrality.Centrality.create_json_url">create_json_url</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.create_svg_url" href="#ArgNav.app.centrality.Centrality.create_svg_url">create_svg_url</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_all_edges" href="#ArgNav.app.centrality.Centrality.get_all_edges">get_all_edges</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_all_schemes_nodes" href="#ArgNav.app.centrality.Centrality.get_all_schemes_nodes">get_all_schemes_nodes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_child_edges" href="#ArgNav.app.centrality.Centrality.get_child_edges">get_child_edges</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_divergent_nodes" href="#ArgNav.app.centrality.Centrality.get_divergent_nodes">get_divergent_nodes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_eigen_centrality" href="#ArgNav.app.centrality.Centrality.get_eigen_centrality">get_eigen_centrality</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_graph" href="#ArgNav.app.centrality.Centrality.get_graph">get_graph</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_graph_url" href="#ArgNav.app.centrality.Centrality.get_graph_url">get_graph_url</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_l_node_list" href="#ArgNav.app.centrality.Centrality.get_l_node_list">get_l_node_list</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_loc_prop_pair" href="#ArgNav.app.centrality.Centrality.get_loc_prop_pair">get_loc_prop_pair</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_nodeset_path" href="#ArgNav.app.centrality.Centrality.get_nodeset_path">get_nodeset_path</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_ra_i_schemes_nodes" href="#ArgNav.app.centrality.Centrality.get_ra_i_schemes_nodes">get_ra_i_schemes_nodes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_s_node_list" href="#ArgNav.app.centrality.Centrality.get_s_node_list">get_s_node_list</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_schemes" href="#ArgNav.app.centrality.Centrality.get_schemes">get_schemes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.get_svg_path" href="#ArgNav.app.centrality.Centrality.get_svg_path">get_svg_path</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.list_nodes" href="#ArgNav.app.centrality.Centrality.list_nodes">list_nodes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.remove_iso_nodes" href="#ArgNav.app.centrality.Centrality.remove_iso_nodes">remove_iso_nodes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.remove_redundant_nodes" href="#ArgNav.app.centrality.Centrality.remove_redundant_nodes">remove_redundant_nodes</a></code></li>
<li><code><a title="ArgNav.app.centrality.Centrality.sort_by_centrality" href="#ArgNav.app.centrality.Centrality.sort_by_centrality">sort_by_centrality</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
